# Структура
Created Friday 28 November 2025
**Иерархия языка**


1. **Переменные** (Variables).
	1. Имя, которому присваивается значение или имя, связанное с данными, которые можно использовать в программе.
	2. Автоматическая типизация.

```python
x = 10 # автоматически определил тип как int
name = "Alice" # автоматически определил тип как str
```

 о
2. **Типы данных** (Data Types):
	1. **Неизменяемые** (immutable). Значение изменить нельзя — можно только создать новое.

> > | Тип       | Eng                   | Описание                 | Пример                | Подсказка                                                                   |
> > |:----------|:----------------------|:-------------------------|:----------------------|:----------------------------------------------------------------------------|
> > | int       | Integer               | целые числа              | x = 10                | Нет ограничений на размер. Можно хранить огромные числа (10**10000)         |
> > | float     | Floating point number | числа с плавающей точкой | x = 3.14              | Погрешности: 0.1 + 0.2 != 0.3 — используйте decimal.Decimal для точности    |
> > | bool      | Boolean               | логические значения      | True, False           | True == 1, False == 0                                                       |
> > | str       | String                | строки                   | x = 'hello'           | Метод .partition() — для разбора строки на 3 части: до, разделитель, после  |
> > | tuple     | Tuple                 | кортежи                  | x = (1, 2, 3)         | Можно юзать как ключ в dict, если все элементы тоже неизменяемые            |
> > | frozenset | Immutable set         | замороженные множества   | x = frozenset([1, 2]) | Полезен как ключ в dict или элемент в set, в отличие от обычного set        |
> > | bytes     | Bytes                 | неизменяемые байты       | x = b"data"           | Быстрее str для передачи данных по сети и работы с файлами, экономит память |

2. **Изменяемые** типы данных (mutable). Можно менять содержимое без создания нового объекта.

> > | Тип                                           | Eng        | Описание                 | Пример                                                                                                                                                                 | Подсказка                                                                               |
> > |:----------------------------------------------|:-----------|:-------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------|
> > | list                                          | List       | списки                   | x = [1, 2, 3]                                                                                                                                                          | Срез lst[:] = [] для очистки без создания нового списка (важно при ссылках)             |
> > | dict                                          | Dictionary | словари                  | x = {"a": 1, "b": 2}                                                                                                                                                   | setdefault(key, default) — удобно для группировки и избежания проверок на наличие ключа |
> > | set                                           | Set        | множества                | x = {1, 2, 3}                                                                                                                                                          | Операции как в математике: A & B, `A                                                    |
> > | bytearray                                     | Bytearray  | изменяемые байты         | x = bytearray(b"abc")                                                                                                                                                  | Можно изменять отдельные байты как элементы списка: x[0] = 65 → b"A..."                 |
> > | user-defined classes \nили \ncustom classes\n |            | пользовательские объекты |  class MyClass:\n    def _init_(self):\n        self.value = 0  # изменяемое состояние\n\nobj = MyClass()\nobj.value = 42  # изменение объекта\nprint(obj.value)  # 42 | Пользовательские классы - их экземпляры можно модифицировать после создания.            |

* ``Как`` проверить изменяемость-- использовать функцию id() — она показывает адрес объекта в памяти. id поменяется — значит, объект новый.



3. **Операторы** (Operators).
	1. **Арифметические** (Arithmetic). Позволяют выполнять математические вычисления.
		* **+** - сложение (Addition) 							2 + 3 → 5
		* **-** - вычитание (Subtraction) 						5 - 2 → 3
		* ***** - умножение (Multiplication) 					2 * 3 → 6
		* **/** - деление (Division), всегда float 				5 / 2 → 2.5
		* **//** - деление без остатка (Floor Division) 		5 // 2 → 2
		* **%** - остаток от деления (Modulus) 			5 % 2 → 1
		* **** **- возведение в степень (Exponentiation) 	2**  3 → 8
	2. **Сравнения** (Comparison). Сравнивают два значения, возвращают True или False.
		* **==** - равно (Equal to)
		* **!=** - не равно (Not equal to)
		* **>** - больше (Greater than)
		* **<** - меньше (Less than)
		* **>=** - больше или равно (Greater or equal)
		* **<=** - меньше или равно (Less or equal)
	3. **Логические** (Logical). Работают с логическими значениями True и False.
		* **and** - истина, если оба выражения истинны (И)
		* **or** - истина, если хотя бы одно истинно (ИЛИ)
		* **not** - инвертирует логическое значение (НЕ)
	4. **Присваивания** (Assignment). Присваивают значение переменной.
		* **=** - простое присваивание (Assign)
		* **+=** - увеличение и присваивание (Add and assign)
		* **-=** - уменьшение и присваивание (Subtract and assign)
		* ***=** - умножение и присваивание (Multiply and assign)
		* **/=** - деление и присваивание (Divide and assign)
		* **//=** - целочисленное деление (Floor divide and assign)
		* **%=** - остаток и присваивание (Modulus and assign)
		* ****=** - степень и присваивание (Power and assign)
	5. **Побитовые** (Bitwise). Выполняют операции над битами целых чисел.
		* **&**	- побитовая конъюнкция (Bitwise AND) (N) (Логическое умножение)
		* **|** - побитовая дизъюнкция (Bitwise OR) (ИЛИ) (Логическое сложение)
		* **^** - побитовая исключающая дизъюнкция (Bitwise XOR) (⊕) (Сложение по модулю 2)
		* **~**	- побитовая инверсия (Bitwise NOT) (НЕ) (Логическое отрицание)
		* **«** - сдвиг битов влево (умножение на 2) (Shift left)
		* **»** - сдвиг битов вправо (деление на 2) (Shift right)
	6. **Принадлежности** (Membership). Проверяют, принадлежит ли элемент коллекции.
		* **in**	- проверяет, содержится ли элемент (In)
		* **not in** - проверяет, не содержится ли элемент (Not in)
	7. **Идентичности** (Identity). Сравнивают, являются ли два объекта одним и тем же в памяти.
		* **is**	- Истина, если оба объекта — один и тот же объект (Is)
		* **is not** - Истина, если объекты — разные (Is not)



4. **Управляющие конструкции**.
	1. **Условные конструкции** (Conditional Statements). **if, elif, else**. Позволяют выполнять код в зависимости от условий.

```python
if x > 0:
    print("Positive")
elif x == 0:
    print("Zero")
else:
    print("Negative")
```

2. **Циклы** (Loops).
	1. **for**. Повторяет блок кода для каждого элемента последовательности.

```python
for i in range(5):
    print(i)

```

2. **while**. Повторяет блок кода, пока условие истинно.

```python
while x < 10:
    x += 1

```
> > **Ключевые слова условных конструкций**:

* **break** — досрочно выйти из цикла
* **continue** — перейти к следующей итерации
* **else** — выполняется после цикла, если он не прервался через break


3. Генераторы списков, множеств, словарей (Comprehensions). Упрощённая форма цикла для создания коллекций.

```python
[x*x for x in range(5)]           # List comprehension
{str(i): i for i in range(3)}     # Dict comprehension
```


5. **Функции** (Functions).
	1. **Определение функции** (Function Definition)

```python
def greet(name):
    return f"Hello, {name}!"
```

2. **Аргументы функций** (Function Arguments).

> > | Название                             | Eng                  | Описание                                                                                          | Пример                                                                                                                              | Подсказка                                             |
> > |:-------------------------------------|:---------------------|:--------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------|
> > | позиционные аргументы                | Positional Arguments | Передаются по порядку, как указано в определении функции.                                         | def greet(name, age):\n    print(f"{name}, {age}")\n\ngreet("Alice", 30)\n                                                          | name получает "Alice", age получает 30 — по порядку.  |
> > | именованные аргументы                | Keyword Arguments    | Передаются по имени параметра, порядок не важен.                                                  | greet(age=30, name="Alice")\n                                                                                                       | То же, что выше, но теперь порядок не имеет значения. |
> > | значения по умолчанию                | Default Values       | Позволяют задать значение по умолчанию, если аргумент не передан.                                 | def greet(name, age=18):\n    print(f"{name}, {age}")\n    \ngreet("Bob")       # age будет 18\ngreet("Bob", 25)   # age будет 25\n |                                                       |
> > | позиционные аргументы в виде кортежа | *args                | Юзать, когда нужно принять произвольное количество позиционных аргументов, сохраняются как tuple. | def add_all(*args):\n    print(args)\n\nadd_all(1, 2, 3)\n# Вывод: (1, 2, 3)\n                                                      |                                                       |
> > | именованные аргументы в виде словаря | **kwargs             | Принимает произвольное количество именованных аргументов, сохраняются как dict.                   | def show_info(**kwargs):\n    print(kwargs)\n\nshow_info(name="Alice", age=30)\n# Вывод: {'name': 'Alice', 'age': 30}\n             |                                                       |

3. Лямбда-функция (Lambda Function). Анонимная однострочная функция.

```python
add = lambda x, y: x + y
```

4. Встроенные функции (Built-in Functions).

```python
len(), type(), print(), input(), range(), sum(), sorted(), enumerate()
```


6. **Коллекции и методы** (Collections & Their Methods). Коллекции — это структуры данных, которые могут хранить несколько значений.
	1. **Список** (List). Упорядоченная изменяемая коллекция (можно менять, добавлять, удалять элементы). Допускает дубликаты, может содержать любые типы.
		* Методы: append(), remove(), pop(), sort(), reverse()

> > > | Название   | Описание                        | Пример                |
> > > |:-----------|:--------------------------------|:----------------------|
> > > | .append(x) | Добавить элемент в конец списка | my_list.append(4)     |
> > > | .pop()     | Удалить и вернуть последний     | my_list.pop() → 3     |
> > > | .remove(x) | Удалить первый x                | my_list.remove(2)     |
> > > | .sort()    | Отсортировать список (in-place) | my_list.sort()        |
> > > | .reverse() | Развернуть список               | my_list.reverse()     |
> > > | len()      | Длина списка                    | len(my_list) → 3      |
> > > | slice      | Взять часть списка              | my_list[1:3] → [2, 3] |

2. **Словарь** (Dictionary). Структура "ключ: значение". Порядок сохраняется с Python 3.7. Ключи должны быть уникальными и неизменяемыми (например, строки, числа, кортежи).
	* Методы: get(), keys(), values(), items(), update(), pop()

> > > | Название  | Описание                               | Пример                     |
> > > |:----------|:---------------------------------------|:---------------------------|
> > > | .get(key) | Получить значение, не выкидывая ошибку | person.get("name")         |
> > > | .keys()   | Получить список всех ключей            | person.keys()              |
> > > | .values() | Получить список всех значений          | person.values()            |
> > > | .items()  | Получить пары ключ-значение            | person.items()             |
> > > | .update() | Обновить словарь                       | person.update({"age": 31}) |
> > > | .pop(key) | Удалить и вернуть значение по ключу    | person.pop("name")         |


3. **Множество** (Set). Неупорядоченная коллекция уникальных элементов. Автоматически удаляет повторы.
	* Методы: add(), remove(), union(), intersection(), difference()

> > > | Название        | Описание                           | Пример                          |
> > > |:----------------|:-----------------------------------|:--------------------------------|
> > > | .add(x)         | Добавить элемент                   | my_set.add(4)                   |
> > > | .remove(x)      | Удалить элемент (ошибка, если нет) | my_set.remove(2)                |
> > > | .discard(x)     | Удалить элемент (без ошибки)       | my_set.discard(5)               |
> > > | .union(other)   | Объединить множества               | set1.union(set2)                |
> > > | .intersection() | Пересечение (общие элементы)       | set1 & set2 или .intersection() |
> > > | .difference()   | Разность                           | set1 - set2 или .difference()   |

4. **Строка** (String). Неизменяемая последовательность символов → методы возвращают новую строку.
	* Методы: upper(), lower(), find(), replace(), split(), strip(), format()

> > > | Название           | Описание                       | Пример                      |
> > > |:-------------------|:-------------------------------|:----------------------------|
> > > | .upper()           | В верхний регистр              | "hi".upper() → "HI"         |
> > > | .lower()           | В нижний регистр               | "HI".lower() → "hi"         |
> > > | .find(substr)      | Найти подстроку                | "abc".find("b") → 1         |
> > > | .replace(old, new) | Заменить подстроку             | "a-b".replace("-", "+")     |
> > > | .split()           | Разделить строку по символу    | "a,b,c".split(",")          |
> > > | .strip()           | Удалить пробелы по краям       | " hello ".strip() → "hello" |
> > > | .format()          | Подставить переменные в строку | "Hi, {}".format("Alice")    |


7. **Классы и ООП** (Classes and OOP). ОПП (OOP — Object-Oriented Programming) — это способ организации кода, где данные и функции объединяются в объекты.
	1. **Класс** (Class). Шаблон (чертёж), по которому создаются объекты.
		* Определяет:
			* какие данные объект будет хранить
			* какие действия он сможет выполнять

```python
class Person:
    pass
```

2. **Объект** (Object / Instance). Экземпляр (конкретный представитель) класса. Создаётся из класса.

```python
p = Person()   # объект класса
```

3. **Конструктор** (Constructor / Initializer). специальный метод, который выполняется при создании объекта. В Python это __init__.

```python
class Person:
    def __init__(self, name):
        self.name = name
```

4. **Атрибут** (Attribute / Property / Field). Переменные, которые принадлежат объекту или классу.
	* self.name — атрибут объекта
	* ClassName.value — атрибут класса

```python
self.age = 20
```

5. **Метод** (Method). Функция внутри класса, которая принадлежит объекту.

```python
def say_hello(self):
    print("Hello")
```

6. **Наследование** (Inheritance). Возможность создать новый класс на основе другого, позволяет переиспользовать код.

```python
class Student(Person):
    pass
```

7. **Инкапсуляция** (Encapsulation). Cокрытие внутренних данных/методов от прямого доступа.
	* В Python уровни доступа условные:
		* **var** - публичное (public)
		* **_var** - защищённое (protected, внутреннее использование)
		* **__var** - приватное (private), Python делает "переименование"
8. **Полиморфизм** (Polymorphism). Возможность использовать один и тот же метод в разных классах, но с разным поведением.

```python
class Cat:
    def sound(self):
        print("Meow")

class Dog:
    def sound(self):
        print("Woof")

# Одинаковый вызов — разное поведение
for animal in [Cat(), Dog()]:
    animal.sound()
```

9. **Магические методы** (Magic methods / Dunder methods). Cпециальные методы с __имя__, позволяют изменять стандартное поведение объектов
	* **__init__** — конструктор
	* **__str__** — текстовое представление
	* **__repr__** — "официальное" представление
	* **__len__** — поведение функции len()
	* **__getitem__** — доступ по индексу
	* **__add__** — поведение оператора +

```python
def __str__(self):
    return f"Person: {self.name}"
```

10. **Атрибуты класса** (Class Attributes). Переменные, общие для всех объектов класса.

```python
class Person:
    species = "Human"   # атрибут класса
```

11. **Атрибуты объекта** (Instance Attributes). Переменные, уникальные для каждого объекта.

```python
self.name = "Alice"
```

12. **Статический метод** (Static Method). Метод, который не использует ни объект (self), ни класс (cls) - просто функция внутри класса.

```python
@staticmethod
def add(a, b):
    return a + b
```

13. **Метод класса** (Class Method). Метод, который работает с классом, а не с объектом, принимает cls.

```python
@classmethod
def create_default(cls):
    return cls("NoName")
```

14. **Абстрактный класс** (Abstract Class). Класс, от которого нельзя создать объект, только унаследоваться; используется как шаблон.

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Square(Shape):
    def area(self):
        return 25

s = Square()
print(s.area())  # 25
```

15. **Интерфейс** (Interface). Набор методов, которые класс должен реализовать (без их реализации). В Python используется абстракция через abc.

```python
# То же, что выше: абстрактный метод = обязательный к реализации
```

16. **Композиция** (Composition). Класс содержит объект другого класса.

```python
class Car:
    def __init__(self):
        self.engine = Engine()
```

17. **Утиная типизация** (Duck Typing). Если что‑то выглядит как утка и крякает — значит, это утка". Главное — поведение, а не тип.

```python
class Duck:
    def quack(self):
        print("Quack!")

class Person:
    def quack(self):
        print("I'm pretending to be a duck")

def make_quack(obj):
    obj.quack()

make_quack(Duck())     # Quack!
make_quack(Person())   # I'm pretending to be a duck
```

8. **Модули и пакеты** (Modules & Packages). 
	* Module — это обычный .py файл, в котором находится код: функции, переменные, классы и т.д. Модуль нужен, чтобы разделять код на части и переиспользовать его в других файлах.
	* Package — это папка с модулями, которая имеет файл __init__.py внутри. Пакет — это способ организовать модули в структуру, как "папки с кодом".
	* __init__.py — что это? Этот файл делает папку пакетом. Может быть пустым, но иногда туда пишут код, который запускается при импорте пакета.
	* Как создать модуль:
		1. Создай .py файл, например my_module.py.
		2. Напиши туда функцию.
		3. Используй этот файл в другом.
	* **Стандартные модули** (stdlib).

> > | Название | Назначение                      |
> > |:---------|:--------------------------------|
> > | math     | Математические функции          |
> > | random   | Генерация случайных чисел       |
> > | os       | Работа с файловой системой      |
> > | sys      | Работа с системными параметрами |
> > | datetime | Работа с датой и временем       |
> > | json     | Работа с JSON-данными           |

1. **Импорт модулей** (Importing Modules)

```python
import math
from os import path
```
> > | Способ                  | Описание              | Пример                                      |
> > |:------------------------|:----------------------|:--------------------------------------------|
> > | import module           | import math           | Импорт всего модуля                         |
> > | from module import name | from math import sqrt | Импорт конкретной функции                   |
> > | import module as alias  | import numpy as np    | Псевдоним (короткое имя)                    |
> > | from module import *    | from math import *    | Импорт всего содержимого (не рекомендуется) |

2. **Установка пакетов** (Installing Packages). Если модуль не входит в стандартную библиотеку, его нужно установить через pip. Если ты пишешь свою библиотеку и хочешь установить её через pip, нужна структура с setup.py.

```python
pip install numpy
```

3. **Создание собственного модуля** (Creating Your Own Module).
	* Любой .py файл можно импортировать как модуль:

```python
# utils.py
def hello(): print("Hi")
```
```python
from utils import hello
```


9. **Исключения** (Exceptions). Это ошибка, которая возникает во время выполнения программы. Чтобы программа не "падала", Python позволяет ловить и обрабатывать такие ошибки.
	1. **Try/Except**. Основной механизм обработки ошибок. except (несколько исключений)

```python
try:
    # код, который может вызвать ошибку
except ТипОшибки:
    # что делать, если ошибка произошла
```

* Пример:

```python
try:
    x = int("abc")
except ValueError:
    print("Ошибка!")
```

2. **Raise**. Используется, когда нужно остановить программу или сообщить об ошибке.

```python
age = -5
if age < 0:
    raise ValueError("Возраст не может быть отрицательным")
```

3. **Else**. Выполняется, если ошибок не было

```python
try:
    x = 10 / 2
except ZeroDivisionError:
    print("На ноль делить нельзя")
else:
    print("Ошибок нет, результат:", x)
```

4. **Finally**. Выполняется ВСЕГДА. Чаще всего используется для освобождения ресурсов.

```python
try:
    file = open("data.txt")
    data = file.read()
except FileNotFoundError:
    print("Файл не найден")
finally:
    print("Это выполнится всегда")
    file.close()
```

5. **Создание собственных исключений**. Можно создать свой класс ошибки.

```python
class MyError(Exception):
    pass

raise MyError("Моя собственная ошибка")
```


10. **Работа с файлами** (File Handling). Это способ читать информацию из файлов и записывать её обратно на диск. Например, сохранять текст, читать настройки, обрабатывать данные и т.д. В Python для этого используется функция open() и контекстный менеджер with. Для работы с путями используй модуль pathlib или os.
	1. **Открытие файла**

```python
file = open("имя_файла", "режим")
```
> > | Название | Назначение                                   |
> > |:---------|:---------------------------------------------|
> > | "r"      | Читать (файл должен существовать)            |
> > | "w"      | Записать (создаёт новый или затирает старый) |
> > | "a"      | Добавить (дозапись в конец файла)            |
> > | "rb"     | Читать в бинарном режиме                     |
> > | "wb"     | Запись в бинарном режиме                     |

2. **Чтение файла**. Всегда закрывай файл f.close() — или лучше используй with.

```python
f = open("file.txt", "r")
text = f.read()           # Читает весь файл как строку
line = f.readline()       # Читает одну строку
lines = f.readlines()     # Читает все строки в список
f.close()                 # Закрывает файл
```

3. **Запись в файл**. Если файла не существует — он создаётся. Если существует — будет перезаписан.

```python
f = open("file.txt", "w")
f.write("Hello, world!")
f.close()
```

4. **Добавление**. Новый текст добавляется в конец, не удаляя предыдущие данные.

```python
f = open("file.txt", "a")
f.write("\nNew line")
f.close()
```

5. **Контекстный менеджер with**. Это лучший способ работы с файлами. Файл автоматически закрывается, даже если произошла ошибка.

```python
with open("file.txt", "r") as f:
    text = f.read()
    print(text)
```


11. **Итераторы и генераторы** (Iterators & Generators).
	1. **Итератор** (Iterator). Это объект, по которому можно пройтись по одному элементу (в любых коллекциях: списки, строки, словари, множества) за раз (например, в for-цикле, он вызывается атоматически). Имеет методы iter() и next() Возвращает следующий элемент при каждом вызове next(). Если элементов больше нет — next() вызовет StopIteration.

```python
numbers = [1, 2, 3]
it = iter(numbers)        # получаем итератор
print(next(it))           # 1
print(next(it))           # 2
print(next(it))           # 3
```

* Проверка на итератор:

```python
hasattr(obj, "__iter__")   # объект итерируемый
hasattr(obj, "__next__")   # объект — итератор
```

2. **Генераторы** (Generators). Это особый тип итератора, который создаётся функцией с ключевым словом yield. Он возвращает значения по одному, не храня их все в памяти. Работает с большими данными (например, миллионы строк), экономит память, позволяет делать ленивые вычисления (lazy evaluation).

```python
def count_up_to(n):
    i = 1
    while i <= n:
        yield i
        i += 1

for num in count_up_to(3):
    print(num)
# Вывод: 1 2 3
```
			

* return - Завершает функцию полностью, возвращает одно значение, нельзя вызывать повторно
* yield - Приостанавливает функцию, возвращает серию значений, можно продолжить с того места
* Генераторное выражение (Generator expression) - похоже на list comprehension, но возвращает генератор.

```python
gen = (x*x for x in range(5))
for num in gen:
    print(num)
```


12. **Декораторы** (Decorators). Это функция, которая принимает другую функцию и возвращает новую, обычно обёрнутую с дополнительным поведением.
	* Зачем нужны:
		* Повторно использовать одинаковое поведение (например, логирование, проверка доступа, измерение времени).
		* Разделять логику и поведение.
		* Добавлять функциональность к функции без её изменения.

```python
# 1. Декоратор — обычная функция
def decorator(func):
    def wrapper():
        print("Перед вызовом")
        func()
        print("После вызова")
    return wrapper
# 2. Применяем декоратор
@decorator
def say_hello():
    print("Привет!")

# 3. Вызываем
say_hello()
```

* @decorator = say_hello = decorator(say_hello)
* Теперь say_hello() вызывает wrapper(), в котором уже вызывается оригинальная функция func()
* Если функция принимает аргументы, декоратор тоже должен их принять.

```python
def decorator(func):
    def wrapper(*args, **kwargs):
        print("До")
        result = func(*args, **kwargs)
        print("После")
        return result
    return wrapper

@decorator
def greet(name):
    print(f"Привет, {name}")

greet("Анна")
```

* Всегда оборачивайте декоратор в wrapper, чтобы не потерять оригинальную функцию. Можно применять несколько декораторов подряд.
* Встроенные декораторы
	* @staticmethod — метод без ссылки на объект
	* @classmethod — метод получает класс вместо объекта
	* @property — превращает метод в "свойство" (как атрибут)



13. **Контекстные менеджеры** (Context Managers). Это конструкция, которая автоматически управляет ресурсами: открывает — выполняет — закрывает. Он гарантирует, что ресурс будет освобождён, даже если в процессе возникла ошибка.
	* Наиболее частый пример — открытие файлов. Здесь with открывает файл и автоматически закрывает его после выполнения блока — даже если произойдёт ошибка внутри.

```python
with open("data.txt", "r") as f:
    text = f.read()
```

* **Встроенные контекстные менеджеры**.

> > | Что делает                | Пример                        |
> > |:--------------------------|:------------------------------|
> > | Открытие файла            | with open(...) as f:          |
> > | Работа с threading.Lock() | with lock:                    |
> > | Временные каталоги/файлы  | with tempfile.TemporaryFile() |
> > | Подключения к БД          | with conn:                    |

* contextlib - удобный способ создать контекстный менеджер.

```python
from contextlib import contextmanager

@contextmanager
def custom_context():
    print("Начало")
    yield "ресурс"
    print("Конец")

with custom_context() as value:
    print("Работа:", value)
```


14. **Асинхронное программирование** (Async Programming). Это способ писать программы, которые не блокируют выполнение во время ожидания "долгих" операций, например:
	* Загрузка данных из интернета
	* Чтение больших файлов
	* Ожидание ответа от базы данных

> Обычно в таких случаях программа ждёт, ничего не делает и "тормозит". Асинхронный код позволяет продолжать работу, пока одна часть ждёт. Этот подход нужно использовать, когда есть долгие I/O операции (интернет, диски, базы данных), НО не подходит для тяжёлых вычислений (используй multiprocessing).
> > | Термин     | Значение                                                      |
> > |:-----------|:--------------------------------------------------------------|
> > | async      | Объявляет функцию как асинхронную                             |
> > | await      | Говорит Python «подожди, но не блокируй»                      |
> > | coroutine  | Асинхронная функция, которая может быть приостановлена        |
> > | event loop | Цикл событий, который управляет выполнением асинхронного кода |

* Как использовать:
	* Объявляем асинхронную функцию

```python
async def say_hello():
    print("Hello")
```

* Вызываем её через event loop (В обычной функции нельзя просто вызвать await — нужно быть внутри async-функции):

```python
import asyncio

async def say_hello():
    print("Hello")

asyncio.run(say_hello())
```

* **Пример с ожиданием** (здесь sleep() — не блокирует выполнение, просто "отдаёт управление" циклу событий):

```python
import asyncio

async def say_later():
    print("Start")
    await asyncio.sleep(2)  # «Заснуть» на 2 секунды
    print("Done after 2 sec")

asyncio.run(say_later())
```

* **Пример: параллельные задачи** (оба задания работают одновременно, несмотря на sleep):

```python
import asyncio

async def task(name, seconds):
    print(f"{name} started")
    await asyncio.sleep(seconds)
    print(f"{name} finished")

async def main():
    await asyncio.gather(
        task("Task A", 2),
        task("Task B", 3)
    )

asyncio.run(main())
```

* **Пример с загрузкой с сервера** (через aiohttp) (здесь мы не блокируем поток во время загрузки страницы):

```python
import aiohttp
import asyncio

async def fetch(url):
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            return await response.text()

async def main():
    html = await fetch("https://example.com")
    print(html[:100])

asyncio.run(main())
```

* **Полезные функции и модули**:

> > > | Функция / модуль      | Что делает                                    |
> > > |:----------------------|:----------------------------------------------|
> > > | asyncio.run()         | Запускает асинхронную функцию                 |
> > > | asyncio.sleep()       | «Поспать» асинхронно                          |
> > > | asyncio.gather()      | Запустить несколько async-функций параллельно |
> > > | aiohttp               | Асинхронные HTTP-запросы                      |
> > > | asyncio.create_task() | Запуск задачи в фоне                          |


15. Дополнительные (**продвинутые**) темы.
	1. **Метаклассы** (Metaclasses). Управляют созданием классов (родвинутый уровень ООП).

```python
class Meta(type):
    def __new__(cls, name, bases, dct):
        return super().__new__(cls, name, bases, dct)
```

2. **Дескрипторы** (Descriptors). Механизм управления доступом к атрибутам объекта.

```python
class Descriptor:
    def __get__(self, obj, objtype): ...
```

3. **Типизация и аннотации** (Typing / Annotations). Повышают читаемость и помогают IDE.

```python
def add(x: int, y: int) -> int:
    return x + y
```

4. **Быстрая генерация классов данных** (Dataclasses).

```python
from dataclasses import dataclass

@dataclass
class Point:
    x: int
    y: int
```

5. **Pattern Matching**

```python
match value:
    case 1:
        print("One")
    case _:
        print("Default")
```

6. **Корутины и событийные циклы** (Coroutines and Event Loops). Глубже, чем просто async/await. Взаимодействие с asyncio, aiohttp, uvicorn и пр.
7. **Packaging / Environment Tools.** Не про сам язык, но важно:
	* venv — виртуальные окружения
	* pip, pyproject.toml, setuptools, poetry — управление зависимостями
	* pytest — тестирование
8. **Многозадачность на уровне процессов и потоков** (Concurrency & Multiprocessing).

```python
from threading import Thread
from multiprocessing import Process
```


16. Дополнительные (**экспертные**) темы.
	1. **Архитектура фреймворков** (Framework Architecture)
		* Назначение – понимание, как устроены Django, FastAPI, Flask и как создать нечто подобное.
			* Что используется:
				* Декораторы → оборачивают маршруты, обработчики
				* Функции как объекты → передаются и хранятся как значения
				* Динамический импорт → __import__(), importlib
				* Регистрация классов и функций в глобальном реестре
				* Метаклассы, дескрипторы — для регистрации и управления поведением классов

```python
routes = {}

def route(path):
    def wrapper(func):
        routes[path] = func
        return func
    return wrapper

@route("/hello")
def hello():
    return "Hello world"
```

2. **Внедрение зависимостей** (Dependency Injection).
	* Назначение – позволяет автоматически передавать зависимости в функции или классы — как это делает FastAPI.
	* Как работает:
		* Используются аннотации типов
		* Контейнер зависимостей хранит объекты
		* Инспекция аргументов через inspect.signature()

```python
from inspect import signature

def resolve(func):
    sig = signature(func)
    for name, param in sig.parameters.items():
        # логика для передачи нужных зависимостей
        ...Инспекция и рефлексия
```

3. **Инспекция и рефлексия** (Introspection & Reflection)
	* Назначение – позволяет "заглянуть внутрь кода": узнать, какие у функции аргументы, какие у объекта атрибуты и т.д.
	* Инструменты:
		* dir() — получить список атрибутов
		* hasattr(), getattr(), setattr()
		* type(), isinstance()
		* callable()
		* inspect — модуль для анализа сигнатур, модулей, исходников

```python
import inspect

def func(x, y): ...
print(inspect.signature(func))  # (x, y)
```

4. **Генерация кода во время выполнения** (Code Generation & Eval).
	* Назначение – создание или изменение кода в рантайме — крайне мощно, но опасно.
	* Инструменты:
		* eval() — выполнить выражение
		* exec() — выполнить любой код
		* compile() — компиляция строк в Python-код
		* Генерация функций через type() или FunctionType

```python
code = "x + 1"
x = 10
print(eval(code))  # 11
```

5. **Байткод и дизассемблирование** (Bytecode & Disassembly).
	* Назначение – анализ производительности, глубокое понимание работы Python-интерпретатора.
	* Инструмент – модуль dis

```python
import dis

def add(x, y): return x + y
dis.dis(add)
```

6. **Профилирование и оптимизация** (Performance Profiling & Optimization).
	* Инструменты:
		* timeit — измерение времени выполнения
		* cProfile — профилирование функций
		* line_profiler — построчное профилирование
		* memory_profiler — замер памяти
	* Подходы:
		* Уменьшение количества аллокаций
		* Использование генераторов вместо списков
		* Использование slots, array, deque, NumPy
7. **Модули на C** (Writing C Extensions).
	* Назначение – создание модулей на C для ускорения вычислений.
	* Что нужно:
		* Писать код на C
		* Использовать API Python: Python.h
		* Собрать модуль с помощью setuptools, distutils, cffi, cython

```cpp
#include <Python.h>

static PyObject* say_hello(PyObject* self, PyObject* args) {
    printf("Hello from C!\n");
    Py_RETURN_NONE;
}
```

8. **Внутренности асинхронности** (Async Internals).
	* Что изучать:
		* asyncio event loop
		* Futures и Tasks
		* Cancellation, timeouts
		* Integration с внешними библиотеками: aiohttp, uvloop
	* Глубже:
		* Понимание, как await превращается в state machine
		* Реализация собственных awaitable объектов
9. **Память и сборка мусора** (Memory Model & GC).
	* Что важно:
		* Объекты хранятся в куче (heap)
		* Все переменные — это ссылки
		* Счётчик ссылок + сборка циклического мусора
	* Инструменты:
	* gc — модуль для управления сборкой мусора
	* sys.getrefcount()
10. **GIL и многопоточность** (GIL & Multithreading).
	* GIL — Global Interpreter Lock
		* Блокирует одновременное выполнение нескольких Python-потоков
		* Многопоточность в Python — не параллельна, а конкурентна
	* Решения:
		* Использовать multiprocessing вместо threading для параллельности
		* Или asyncio — для неблокирующих задач
11. **Встраивание Python в C/С++** (Python Embedding & C API)
	* Что такое:
		* Запуск Python из C/С++ приложений
		* Подключение Python-логики к другим языкам



17. Дополнительные (**суперэкспертные**) темы.
	1. Собственные механизмы импорта (Custom Import Systems).
		* Что это:
			* Можно изменить, как работает import в Python.
			* Используется sys.meta_path, importlib.abc.Loader, Finder.
		* Для чего:
			* Загружать модули из базы данных, zip-архивов, шифрованных файлов.
			* Реализация hot reload, плагинов, sandbox-импорта.

```python
import sys
class MyFinder:
    def find_spec(self, name, path, target=None):
        print("Импортируем:", name)

sys.meta_path.insert(0, MyFinder())
```

2. **Собственный байткод-интерпретатор**.
	* Что это:
		* Создание своего интерпретатора Python, основанного на bytecode.
		* Использование dis, opcode, frame.
	* Применение:
		* Безопасное выполнение кода (sandbox)
		* Логирование или трассировка исполнения
		* Игровые движки, mini-VM
3. **Изменение синтаксического дерева** (Abstract Syntax Tree (AST) Manipulation).
	* Что это:
		* Python-код можно разобрать в дерево — ast.parse()
		* Можно модифицировать его и скомпилировать обратно
	* Применение:
		* Линтеры (например, flake8, black)
		* Система макросов
		* Инструменты статического анализа
		* Code Transformers

```python
import ast
tree = ast.parse("x = 1 + 2")
```

4. **Writing Your Own Language on Top of Python**.
	* Что это:
		* Ты можешь создать новый DSL (Domain Specific Language), компилируемый в Python или байткод.
		* Пример: Hy (Lisp-подобный язык на базе Python)
	* Как:
		* Использовать ast, eval, compile
		* Или писать препроцессор, который преобразует твой язык в Python
5. **Alternative Python Implementations**.
	* Что это:
		* Изучение и работа с другими реализациями Python:
		* PyPy — JIT-компиляция, быстрее CPython
		* Cython — компилируемый Python
		* MicroPython, CircuitPython — для микроконтроллеров
		* Jython — Python на JVM
		* IronPython — Python на .NET
	* Применение:
		* Оптимизация
		* Кросс-платформенная разработка
		* Встраивание в другие экосистемы
6. **Building Your Own Python Interpreter**.
	* Что это:
		* Чтение исходников CPython (на C)
		* Сборка Python вручную из исходников
		* Изменение поведения языка на уровне ядра
	* Применение:
		* Встраивание Python в свои C/C++ приложения
		* Изучение работы языков программирования
		* Написание новых фич в Python (например, фичи для PEP)
7. **Working on the Python Language Itself** (CPython Core Dev).
	* Что включает:
		* Участие в разработке CPython (официальный репозиторий)
		* Реализация и тестирование новых PEP
		* Оптимизация интерпретатора, garbage collector, stdlib
		* Участие в python-dev и PyCon
8. **Meta-circular Python** (Python, написанный на Python).
	* Что это:
		* Концепт: написать интерпретатор Python на самом Python (или байткод-VM)
	* Примеры:
		* PyPy — написан на RPython (ограниченный подмножество Python)
		* Mython — Python с макросами
		* Batavia — интерпретатор байткода на JavaScript
9. **PEP Process & Language Governance.**
	* Что это:
		* Участие в разработке языка через PEP — Python Enhancement Proposals
	* Роль:
		* Написание PEP (например, PEP 484 — аннотации типов)
		* Обсуждение новых фич, поведение языка
		* Голосование в Steering Council (если ты core-dev)
10. **Python VM Hacking** (Изменение CPython в C). Это уже почти уровень разработки нового языка программирования.
	* Что это:
		* Изменение и пересборка ядра Python на C:
		* Изменить типы объектов
		* Добавить ключевые слова
		* Новое поведение интерпретатора



18. Направления развития, если понял Python от и до.
	1. **Межъязыковая интеграция** (Language Interoperability & VM Design).

> > | Что                                                  | Для чего                |
> > |:-----------------------------------------------------|:------------------------|
> > |  Встраивать Python в C++ / Rust-приложения           | Игровые движки, системы |
> > |  Вызывать Rust/C-код из Python (cffi, ctypes)        | Скорость                |
> > | Создавать Python-подобные DSL внутри C++ / Go        | DSL                     |
> > | Использовать Python вместе с JVM (.jar) через Jython | Корпоративные системы   |

2. **Разработка собственных языков программирования**.

> > | Что изучать                         | Где применимо                  |
> > |:------------------------------------|:-------------------------------|
> > | Теория компиляторов                 | Университетские курсы, LLVM    |
> > | Парсеры, лексеры (ANTLR, PLY, Lark) | Парсинг, DSL                   |
> > | Построение AST, bytecode            | Виртуальные машины             |
> > | Генерация IR / JIT                  | LLVM, PyPy, Numba              |
> > | VM Design & Optimization            | Языки, фреймворки, WebAssembly |

3. **Python в нестандартных и экстремальных средах**.

> > | Тема                                    | Пример                                      |
> > |:----------------------------------------|:--------------------------------------------|
> > | Python в микроконтроллерах              | MicroPython, CircuitPython                  |
> > | Python в браузере                       | Pyodide (на WebAssembly)                    |
> > | Python в блокчейне                      | Smart-контракты на Vyper                    |
> > | Python в операционных системах          | Встраивание в ядра, инициализация окружений |
> > | Python на GPU                           | CuPy, Numba, PyTorch internals              |
> > | Python в распределённых VM / sandbox'ах | Pyodide, Brython, WASM, jailed Python       |

4. **Создание нового Python.**
	* Форк CPython и реализация нового поведения языка
	* Придумывание новой философии интерпретатора
	* Введение новых фич без одобрения PEP



